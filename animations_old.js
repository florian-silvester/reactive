// This file was generated by Slater.app - Ilke.js


// Custom cursor
//--------------------------//
const cursor = document.querySelector('.projects_mouse_label');
const labelText = cursor.querySelector('.label_text');
const labelDot = cursor.querySelector('.label_dot');

// Update cursor position
document.addEventListener('mousemove', (event) => {
  gsap.to(cursor, {
    x: event.clientX,
    y: event.clientY,
    duration: 0.1, // Slight trailing effect
    ease: "power2.out"
  });
});

// Function to update label text and scale label_dot
function updateCursorLabel(text, scaleDot = false) {
  labelText.textContent = text || '';
  gsap.to(labelDot, {
    scale: scaleDot ? 1.30 : 1, // Scale the dot slightly if desired
    duration: 0.1,
    ease: 'power2.out'
  });
}

// Change label text to "View" when hovering over .project_link
document.querySelectorAll('.project_link').forEach(link => {
  link.addEventListener('mouseenter', () => {
    updateCursorLabel("View", true); // Scale the dot
  });
  link.addEventListener('mouseleave', () => {
    updateCursorLabel("", false);
  });
});

// For each .slider_modal...
document.querySelectorAll('.slider_modal').forEach(modal => {

  // 1) Hovering entire modal -> "Close"
  modal.addEventListener('mouseenter', () => {
    updateCursorLabel("Close", false);
  });
  // Leaving entire modal -> clear label
  modal.addEventListener('mouseleave', () => {
    updateCursorLabel("", false);
  });

  // 2) Hovering a .swiper-slide itself -> clear label (we want no text)
  modal.querySelectorAll('.swiper-slide').forEach(slide => {
    slide.addEventListener('mouseenter', () => {
      updateCursorLabel("", false);
    });
    slide.addEventListener('mouseleave', () => {
      // Revert to "Close" when leaving the slide
      updateCursorLabel("Close", false);
    });

    // 3) Hovering children of a .swiper-slide -> show "Swipe"
    //    Use :scope > * if you only want direct children
    //    or .swiper-slide * for all descendants
    slide.querySelectorAll(':scope > *').forEach(child => {
      child.addEventListener('mouseenter', (e) => {
        e.stopPropagation(); // Prevent parent slide event
        updateCursorLabel("Swipe", false);
      });
      child.addEventListener('mouseleave', (e) => {
        e.stopPropagation(); // Prevent parent slide event
        updateCursorLabel("", false);
      });
    });
  });

  // If you have a CTA area that should show no label
  modal.querySelectorAll('.slider-main_bottom-wrapper').forEach(wrapper => {
    wrapper.addEventListener('mouseenter', () => {
      updateCursorLabel("", false);
    });
    wrapper.addEventListener('mouseleave', () => {
      updateCursorLabel("Close", false);
    });
  });
});

// If you want the same “hover effect” for nav items or details:
document.querySelectorAll('.nav_item_wrap, .slider_details_wrap').forEach(element => {
  element.addEventListener('mouseenter', () => {
    // Enlarge the dot, no text
    updateCursorLabel("", true);
  });
  element.addEventListener('mouseleave', () => {
    updateCursorLabel("", false);
  });
});

//--hide default cursor--//
///--------------------------/
const observer = new MutationObserver(() => {
  document.querySelectorAll("*").forEach(el => {
    el.style.cursor = "none";
  });
});
observer.observe(document.body, { attributes: true, childList: true, subtree: true });

// intro
///--------------------------/
// Register ScrollTrigger
gsap.registerPlugin(ScrollTrigger);

// Detect if this is the first page load, navigation, or refresh
const isHardRefresh =
  performance.navigation.type === performance.navigation.TYPE_RELOAD;
const isInitialLoad = !sessionStorage.getItem("pageLoaded") || isHardRefresh;

// Store that the page has been loaded
if (!isHardRefresh) {
  sessionStorage.setItem("pageLoaded", "true");
}

// Adjust animation durations based on context
const fadeLayerDuration = isInitialLoad ? 1.5 :
  0.75; // Slower for initial load, faster for navigation
const fadeLayerDelay = isInitialLoad ? 1.5 : 0.5; // Shorter delay for navigation
const logoWrapDuration = isInitialLoad ? 1.5 : 0.75; // Match speeds for .intro_logo_wrap
const logoWrapDelay = fadeLayerDelay; // Sync with fade layer

// 1. Fade out .intro_fade_layer
gsap.to(".intro_fade_layer", {
  opacity: 0,
  delay: fadeLayerDelay,
  duration: fadeLayerDuration,
  ease: "expo.inOut",
  onComplete: () => {
    document.querySelector(".intro_fade_layer")?.remove();
  }
});

// 2. Automatic Fade-Out of .intro_logo_wrap
gsap.to(".intro_logo_wrap", {
  opacity: 0,
  delay: logoWrapDelay, // Matches fade layer delay
  duration: logoWrapDuration,
  ease: "expo.inOut",
  onComplete: () => {
    // Optional: Remove the element from the DOM
  }
});

// 3. Scroll-triggered Fade-In of .intro_logo_wrap when scrolling back to top
ScrollTrigger.create({
  trigger: "body",
  start: "top top",
  onEnterBack: () => {
    console.log("ScrollTrigger: onEnterBack triggered"); // Debugging
    gsap.to(".intro_logo_wrap", {
      opacity: 1,
      duration: 0.5,
      ease: "expo.inOut"
    });
  },
  markers: false // Set to true for debugging
});

//--scroll tigger--//
///--------------------------/
// Adjust opacity and remove filter during scroll for .project_img_overlay elements
gsap.utils.toArray('.project_img_overlay').forEach(function (overlay) {
  gsap.to(overlay, {
    opacity: 0, // Set opacity to 0% on scroll
    filter: 'none', // Remove background filter added by Webflow
    duration: 0.7, // Fast animation duration
    ease: 'expo.inOut', // Smooth ease-out transition
    scrollTrigger: {
      trigger: overlay, // Trigger scroll effect when the overlay is in view
      start: 'top 60%', // Start the effect when the element comes into view
      toggleActions: 'play none none none', // Only play once on scroll
    }
  });
});

//--hover effects--//
//--------------------------//

// Add hoverDisabled variable to control hover activation
let hoverDisabled = false;

const projectsItems = document.querySelectorAll('.projects_item');

function initProjectsItems() {
  const isDesktop = window.matchMedia('(min-width: 768px)').matches;

  projectsItems.forEach(item => {
    const imgWrap = item.querySelector('.project_img_wrap');
    const bottomWrap = item.querySelector('.project_bottom_wrap');
    const descriptionWrap = bottomWrap ? bottomWrap.querySelector('.project_description_wrap') :
      null;

    // Remove existing event listeners to prevent duplicate handlers
    imgWrap.removeEventListener('mouseenter', imgWrap.mouseEnterHandler);
    imgWrap.removeEventListener('mouseleave', imgWrap.mouseLeaveHandler);

    if (isDesktop) {
      // Desktop: Keep hover effects
      // Set initial state for bottomWrap and descriptionWrap
      gsap.set([bottomWrap, descriptionWrap], { autoAlpha: 0 });

      const mouseEnterHandler = function () {
        if (hoverDisabled)
          return; // Added this line to prevent immediate hover effect after closing modal
        // Fade in bottomWrap and descriptionWrap at the same time
        gsap.to([bottomWrap, descriptionWrap], {
          autoAlpha: 1,
          duration: 0.5,
          ease: 'power3.inOut'
        });
      };

      const mouseLeaveHandler = function () {
        // Fade out bottomWrap and descriptionWrap at the same time
        gsap.to([bottomWrap, descriptionWrap], {
          autoAlpha: 0,
          duration: 0.5,
          ease: 'power3.inOut'
        });
      };

      imgWrap.addEventListener('mouseenter', mouseEnterHandler);
      imgWrap.addEventListener('mouseleave', mouseLeaveHandler);

      // Store handlers to remove them later
      imgWrap.mouseEnterHandler = mouseEnterHandler;
      imgWrap.mouseLeaveHandler = mouseLeaveHandler;

    } else {
      // Mobile: Remove hover effects and make all elements visible
      gsap.set([bottomWrap, descriptionWrap], { autoAlpha: 1 });
    }
  });
}

// Initialize on page load
initProjectsItems();

// Re-initialize on window resize to handle screen size changes
window.addEventListener('resize', initProjectsItems);

//-- Add Click Outside to Close Modal --//
document.addEventListener('click', function (e) {
  projectsItems.forEach(item => {
    // If the click is outside the current .projects_item
    if (!item.contains(e.target)) {
      const bottomWrap = item.querySelector('.project_bottom_wrap');

      // Hide the bottomWrap using GSAP
      gsap.to(bottomWrap, {
        autoAlpha: 0,
        duration: 0.2,
        ease: 'expo.inOut',
        overwrite: 'auto'
      });
    }
  });
});

//--Modal--//
//--------------------------//
function closeModal(modal) {
  const modalId = modal.getAttribute('data-id');
  const swiperInstance = swiperInstances[modalId];

  // Reset swiper completely
  if (swiperInstance) {
    swiperInstance.slideTo(0, 0);
    swiperInstance.update();
    if (swiperInstance.scrollbar) {
      swiperInstance.scrollbar.updateSize();
      swiperInstance.scrollbar.setTranslate();
    }
  }

  // Reset all overlays and descriptions to initial state
  const allOverlays = modal.querySelectorAll('.slider_details_overlay');
  allOverlays.forEach(overlay => {
    const descriptionWrap = overlay.querySelector('.project_description_wrap');
    gsap.to(overlay, {
      autoAlpha: 0,
      y: 200,
      duration: 0.5,
      ease: "expo.inOut",
      onComplete: () => {
        gsap.set(overlay, { y: -50 }); // Reset to initial position
        gsap.set(descriptionWrap, { autoAlpha: 0 });
      }
    });
  });

  // Reset and fade in title wrapper
  const sliderTitleWrapper = modal.querySelector('.slider_title_wrapper');
  gsap.to(sliderTitleWrapper, {
    autoAlpha: 1,
    duration: 0.3,
    ease: "expo.inOut"
  });

  // Close modal with cleanup
  gsap.to(modal, {
    opacity: 0,
    scale: 0.9,
    duration: 0.3,
    onComplete: function () {
      // Reset all slides to initial state
      const slides = modal.querySelectorAll('.swiper-slide');
      slides.forEach(slide => {
        gsap.set(slide, {
          opacity: 1,
          y: 0,
          scale: 1,
          filter: ''
        });
      });

      // Reset modal components
      gsap.set(modal, { display: 'none' });
      gsap.set(modal.querySelector('.slider_swiper_wrap'), {
        display: 'block',
        opacity: 1,
        y: 0,
        scale: 1
      });
      gsap.set(modal.querySelector('.slider_text_wrap'), {
        display: 'none',
        opacity: 0,
        y: 0,
        scale: 0.5
      });

      // Reset hover state with delay
      hoverDisabled = true;
      setTimeout(() => {
        hoverDisabled = false;
      }, 500);
    }
  });
}

// Add event listener to .project_link to open modal
document.querySelectorAll('.project_link').forEach(function (link) {
  link.addEventListener('click', function (e) {
    e.preventDefault();

    // Get the data-id from the closest parent with the expected class
    const projectId = this.closest('.projects_item, .projects_list_item, .project_item')
      ?.getAttribute('data-id');

    // Find the corresponding modal using the same data-id
    const modal = document.querySelector(`.slider_modal[data-id="${projectId}"]`);

    if (modal) {
      // Show the modal
      gsap.set(modal, { display: 'flex' });

      // Animate modal to scale from 0.3 to 1 with opacity fade-in
      gsap.fromTo(
        modal, { opacity: 0, scale: 0.3 },
        {
          opacity: 1,
          scale: 1,
          duration: 0.8,
          ease: "expo.inOut",
          onComplete: function () {
            // Initialize swiper only now (lazy loading!)
            const swiperInstance = initializeSwiper(projectId);
            if (swiperInstance) {
              // Force reflow
              modal.style.display = "block";
              modal.offsetHeight; // Trigger browser reflow

              setTimeout(() => {
                swiperInstance.update(); // Recalculate Swiper layout
                if (swiperInstance.scrollbar) {
                  swiperInstance.scrollbar.updateSize(); // Fix scrollbar size
                  swiperInstance.scrollbar.setTranslate();
                  swiperInstance.scrollbar.$el.css('opacity',
                  1); // Make scrollbar visible
                }
              }, 100); // Small delay ensures correct rendering
            }
          }
        }
      );

      // Stagger the appearance of the .swiper-slide elements with a scale-up effect
      const slides = modal.querySelectorAll('.swiper-slide');
      gsap.fromTo(
        slides, { opacity: 0, y: 0, scale: 0.8 },
        {
          opacity: 1,
          y: 0,
          scale: 1,
          duration: 0.5,
          stagger: 0.2,
          delay: 0.1
        }
      );

      // ---------------------------------------------------------
      // "Click outside" listener to close the modal.
      // On desktop: Close if the click is outside .slider-main_bottom-wrapper AND .swiper-slide.
      // On tablet and smaller: Close if the click is outside .slider-main_bottom-wrapper only.
      // ---------------------------------------------------------
      modal.addEventListener('click', function onModalClick(e) {
        const insideBottomWrapper = e.target.closest('.slider-main_bottom-wrapper');
        const insideSlide = e.target.closest('.swiper-slide');

        // Check if the screen width is for tablet/smaller or desktop
        if (window.innerWidth < 1024) {
          // Tablet and smaller: Close if the click is outside .slider-main_bottom-wrapper
          if (!insideBottomWrapper) {
            closeModal(modal);

            // Optional cleanup: Remove the listener after closing
            modal.removeEventListener('click', onModalClick);
          }
        } else {
          // Desktop: Close if the click is outside both .slider-main_bottom-wrapper and .swiper-slide
          if (!insideBottomWrapper && !insideSlide) {
            closeModal(modal);

            // Optional cleanup: Remove the listener after closing
            modal.removeEventListener('click', onModalClick);
          }
        }
      }); // <-- Closing bracket for modal.addEventListener
    } else {
      console.warn(`No modal found with data-id="${projectId}"`);
    }
  }); // <-- Closing bracket for link.addEventListener
}); // <-- Closing bracket for querySelectorAll.forEach

//--swiper--//
//--------------------------//
// 3 columns

// Create an object to store Swiper instances
const swiperInstances = {};

// Function to initialize swiper only when needed
function initializeSwiper(projectId) {
  // Only initialize if not already done
  if (swiperInstances[projectId]) {
    return swiperInstances[projectId];
  }

  const sliderComponent = document.querySelector(`[data-id="${projectId}"] .slider_component`);
  if (!sliderComponent) {
    console.warn(`No slider component found for project ${projectId}`);
    return null;
  }

  // Retrieve the CSS variable value
  const rootStyles = getComputedStyle(document.documentElement);
  const siteMarginValue = rootStyles.getPropertyValue("--site--margin").trim();

  // Create a temporary element to compute the pixel value
  const tempDiv = document.createElement('div');
  tempDiv.style.width = siteMarginValue;
  tempDiv.style.position = 'absolute'; // Prevents affecting the layout
  tempDiv.style.visibility = 'hidden';
  document.body.appendChild(tempDiv);
  const siteMargin = parseFloat(getComputedStyle(tempDiv).width);
  document.body.removeChild(tempDiv);

  let loopMode = false;
  if (sliderComponent.getAttribute("loop-mode") === "true") {
    loopMode = true;
  }
  let sliderDuration = 300;
  if (sliderComponent.getAttribute("slider-duration") !== undefined) {
    sliderDuration = +sliderComponent.getAttribute("slider-duration");
  }

  // Find the swiper element
  const swiperElement = sliderComponent.querySelector(".swiper");

  // Initialize Swiper
  const swiperInstance = new Swiper(swiperElement, {
    speed: sliderDuration,
    loop: loopMode,
    autoHeight: false,
    centeredSlides: loopMode,
    followFinger: true,
    freeMode: false,
    slideToClickedSlide: false,
    slidesPerView: 1,
    spaceBetween: siteMargin,
    rewind: false,
    mousewheel: {
      forceToAxis: true
    },
    keyboard: {
      enabled: true,
      onlyInViewport: true
    },
    breakpoints: {
      // mobile landscape
      480: {
        slidesPerView: 1,
        spaceBetween: siteMargin
      },
      // tablet
      768: {
        slidesPerView: 2,
        spaceBetween: siteMargin
      },
      // desktop
      992: {
        slidesPerView: 3,
        spaceBetween: siteMargin
      }
    },
    navigation: {
      nextEl: sliderComponent.querySelector(".swiper-next"),
      prevEl: sliderComponent.querySelector(".swiper-prev"),
      disabledClass: "is-disabled"
    },
    slideActiveClass: "is-active",
    slideDuplicateActiveClass: "is-active"
  });

  // Store the Swiper instance
  swiperInstances[projectId] = swiperInstance;
  
  return swiperInstance;
}

// PERFORMANCE FIX: We removed the immediate initialization loop that was causing the problem!
// Previously: ALL 39+ swipers initialized on page load = browser death
// Now: Swipers only initialize when their modal opens = much better performance

//--modal details--//
//--------------------------//

// Select the elements
const detailsWrap = document.querySelectorAll('.slider_details_wrap');
const detailsOverlays = document.querySelectorAll('.slider_details_overlay');

// Select .swiper-slide elements
const swiperSlides = document.querySelectorAll('.swiper-slide');

// Set initial state for overlays and description elements
detailsOverlays.forEach(overlay => {
  gsap.set(overlay, { autoAlpha: 0, y: -50 });
  const descriptionWrap = overlay.querySelector('.project_description_wrap');
  gsap.set(
    descriptionWrap, { autoAlpha: 0 }
  ); // Set initial state for project_description_wrap
});

detailsWrap.forEach((wrap, index) => {
  let isOpen = false;
  wrap.addEventListener('click', () => {
    const overlay = detailsOverlays[index];
    const descriptionWrap = overlay.querySelector('.project_description_wrap');

    // **Select .slider_title_wrapper within the same modal**
    const modal = overlay.closest('.slider_modal');
    const sliderTitleWrapper = modal.querySelector('.slider_title_wrapper');

    if (isOpen) {
      // Close the overlay
      gsap.to(overlay, {
        autoAlpha: 0,
        y: 200,
        duration: 0.5,
        ease: "expo.inOut",
        onComplete: () => {
          // Reset project_description_wrap visibility when overlay closes
          gsap.set(descriptionWrap, { autoAlpha: 0 });
        }
      });

      // **Fade in .slider_title_wrapper when overlay is closed**
      gsap.to(sliderTitleWrapper, {
        autoAlpha: 1,
        duration: 0.3,
        ease: "expo.inOut"
      });

      // Remove the filter from .swiper-slide when overlay is closed
      swiperSlides.forEach(slide => {
        slide.style.filter = ''; // Remove any applied filters
      });
    } else {
      // Open the overlay
      gsap.to(overlay, {
        autoAlpha: 1,
        y: 0,
        duration: 0.35,
        ease: "expo.inOut",
      });

      // Start fading in project_description_wrap slightly before overlay animation completes
      gsap.to(descriptionWrap, {
        autoAlpha: 1,
        duration: 0.2,
        ease: "expo.inOut",
        delay: 0.4 // Adjust this to control the overlap; 0.4 starts after overlay animation
      });

      // **Fade out .slider_title_wrapper when overlay is opened**
      gsap.to(sliderTitleWrapper, {
        autoAlpha: 0,
        duration: 0.3,
        ease: "expo.inOut"
      });

      // Apply filter to .swiper-slide when overlay is opened
      swiperSlides.forEach(slide => {
        slide.style.filter =
          'blur(40px) brightness(100%)'; // Apply the desired filter
      });
    }

    isOpen = !isOpen;
  });

  // Close overlay when clicking inside it
  const overlay = detailsOverlays[index];
  overlay.addEventListener('click', () => {
    if (isOpen) {
      const descriptionWrap = overlay.querySelector('.project_description_wrap');
      const modal = overlay.closest('.slider_modal');
      const sliderTitleWrapper = modal.querySelector('.slider_title_wrapper');

      gsap.to(overlay, {
        autoAlpha: 0,
        y: 100,
        duration: 0.4,
        ease: "expo.inOut",
        onComplete: () => {
          gsap.set(descriptionWrap, { autoAlpha: 0 });
        }
      });

      // **Fade in .slider_title_wrapper when overlay is closed by clicking overlay**
      gsap.to(sliderTitleWrapper, {
        autoAlpha: 1,
        duration: 0.3,
        ease: "expo.inOut"
      });

      // Remove the filter from .swiper-slide when overlay is closed by clicking overlay
      swiperSlides.forEach(slide => {
        slide.style.filter = ''; // Remove any applied filters
      });

      isOpen = false;
    }
  });
});

//--thumbnail hover--//
///--------------------------/
// Initially hide all .project_list_img_wrap elements (opacity set to 0 in CSS)
gsap.set('.list_thumb_wrap', { opacity: 0 });

// Select all .projects_list_item elements
document.querySelectorAll('.projects_list_item').forEach(function (item) {

  // Add hover (mouseenter) event to show the image wrapper
  item.addEventListener('mouseenter', function () {
    const imgWrap = this.querySelector('.list_thumb_wrap');
    if (imgWrap) {
      gsap.to(imgWrap,
      {
        opacity: 1,
        duration: 0.6, // Smooth duration
        ease: 'power2.out' // Smoother ease
      });
    }
  });

  // Add leave (mouseleave) event to hide the image wrapper
  item.addEventListener('mouseleave', function () {
    const imgWrap = this.querySelector('.list_thumb_wrap');
    if (imgWrap) {
      gsap.to(imgWrap,
      {
        opacity: 0,
        duration: 0.6, // Smooth fade out duration
        ease: 'power2.out' // Smoother easing for fade out
      });
    }
  });
});

//--title in view--//
///--------------------------/
gsap.registerPlugin(ScrollTrigger);

// Apply the animation individually to each .item_title_wrap
gsap.utils.toArray(".item_title").forEach((title) => {
  gsap.fromTo(
    title, { opacity: 0 }, // Start state
    {
      opacity: 1, // End state
      duration: 1,
      scrollTrigger: {
        trigger: title,
        start: "top 80%", // Adjust as needed for desired trigger position
        toggleActions: "play none none none" // Only play once
      }
    }
  );
});

